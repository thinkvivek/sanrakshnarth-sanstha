USE msdb;
GO

SELECT  
    j.name AS JobName,  
    s.name AS ScheduleName,  
    CASE j.enabled WHEN 1 THEN 'Enabled' ELSE 'Disabled' END AS JobEnabled,  
    CASE s.enabled WHEN 1 THEN 'Enabled' ELSE 'Disabled' END AS ScheduleEnabled,  
    ss.freq_type,  
    ss.freq_interval,  
    ss.freq_subday_type,  
    ss.freq_subday_interval,  
    ss.active_start_time AS StartTimeHHMMSS,  
    'Next Run: ' +  
        CONVERT(VARCHAR,  
            msdb.dbo.agent_datetime(js.next_run_date, js.next_run_time), 120) AS NextRunDateTime  
FROM msdb.dbo.sysjobs j  
INNER JOIN msdb.dbo.sysjobschedules js ON j.job_id = js.job_id  
INNER JOIN msdb.dbo.sysschedules s ON js.schedule_id = s.schedule_id  
INNER JOIN msdb.dbo.sysschedules ss ON s.schedule_id = ss.schedule_id  
ORDER BY NextRunDateTime;


USE msdb;
GO

WITH JobDurations AS
(
    SELECT  
        j.job_id,
        AVG(DATEDIFF(SECOND,  
            msdb.dbo.agent_datetime(h.run_date, h.run_time),  
            DATEADD(SECOND, h.run_duration % 100 + ((h.run_duration / 100) % 100) * 60 + (h.run_duration / 10000) * 3600,  
                    msdb.dbo.agent_datetime(h.run_date, h.run_time))
        )) AS AvgSeconds
    FROM msdb.dbo.sysjobs j
    INNER JOIN msdb.dbo.sysjobhistory h ON j.job_id = h.job_id
    WHERE h.step_id = 0  -- Only job outcome, not individual steps
    GROUP BY j.job_id
)
SELECT  
    j.name AS JobName,
    s.name AS ScheduleName,
    CASE j.enabled WHEN 1 THEN 'Enabled' ELSE 'Disabled' END AS JobEnabled,
    CASE s.enabled WHEN 1 THEN 'Enabled' ELSE 'Disabled' END AS ScheduleEnabled,

    -- Frequency Type Meaning
    CASE ss.freq_type
        WHEN 1 THEN 'One-time'
        WHEN 4 THEN 'Daily'
        WHEN 8 THEN 'Weekly'
        WHEN 16 THEN 'Monthly (Day of Month)'
        WHEN 32 THEN 'Monthly (Relative to Weekday)'
        WHEN 64 THEN 'When SQL Agent Starts'
        WHEN 128 THEN 'When CPU Idle'
        ELSE 'Other'
    END AS FrequencyType,

    -- Frequency Interval Meaning
    CASE ss.freq_type
        WHEN 8 THEN -- Weekly
            STUFF(
                CASE WHEN ss.freq_interval & 1  <> 0 THEN ', Sunday'    ELSE '' END +
                CASE WHEN ss.freq_interval & 2  <> 0 THEN ', Monday'    ELSE '' END +
                CASE WHEN ss.freq_interval & 4  <> 0 THEN ', Tuesday'   ELSE '' END +
                CASE WHEN ss.freq_interval & 8  <> 0 THEN ', Wednesday' ELSE '' END +
                CASE WHEN ss.freq_interval & 16 <> 0 THEN ', Thursday'  ELSE '' END +
                CASE WHEN ss.freq_interval & 32 <> 0 THEN ', Friday'    ELSE '' END +
                CASE WHEN ss.freq_interval & 64 <> 0 THEN ', Saturday'  ELSE '' END
            , 1, 2, '')
        WHEN 4 THEN CAST(ss.freq_interval AS VARCHAR) + ' day(s)'
        WHEN 16 THEN 'Day ' + CAST(ss.freq_interval AS VARCHAR)
        WHEN 32 THEN 
            CASE ss.freq_relative_interval
                WHEN 1 THEN 'First '
                WHEN 2 THEN 'Second '
                WHEN 4 THEN 'Third '
                WHEN 8 THEN 'Fourth '
                WHEN 16 THEN 'Last '
                ELSE ''
            END +
            CASE ss.freq_interval
                WHEN 1 THEN 'Sunday'
                WHEN 2 THEN 'Monday'
                WHEN 3 THEN 'Tuesday'
                WHEN 4 THEN 'Wednesday'
                WHEN 5 THEN 'Thursday'
                WHEN 6 THEN 'Friday'
                WHEN 7 THEN 'Saturday'
                WHEN 8 THEN 'Day'
                WHEN 9 THEN 'Weekday'
                WHEN 10 THEN 'Weekend day'
            END
        ELSE CAST(ss.freq_interval AS VARCHAR)
    END AS FrequencyIntervalMeaning,

    -- Subday Frequency Meaning
    CASE ss.freq_subday_type
        WHEN 1 THEN 'Occurs once at the specified time'
        WHEN 2 THEN 'Occurs every ' + CAST(ss.freq_subday_interval AS VARCHAR) + ' seconds'
        WHEN 4 THEN 'Occurs every ' + CAST(ss.freq_subday_interval AS VARCHAR) + ' minutes'
        WHEN 8 THEN 'Occurs every ' + CAST(ss.freq_subday_interval AS VARCHAR) + ' hours'
        ELSE 'Unknown'
    END AS SubdayFrequencyMeaning,

    RIGHT('000000' + CAST(ss.active_start_time AS VARCHAR(6)), 6) AS StartTimeHHMMSS,

    CONVERT(VARCHAR, msdb.dbo.agent_datetime(js.next_run_date, js.next_run_time), 120) AS NextRunDateTime,

    CONVERT(VARCHAR, msdb.dbo.agent_datetime(h.run_date, h.run_time), 120) AS LastRunDateTime,

    CAST(ISNULL(d.AvgSeconds / 60, 0) AS DECIMAL(10,2)) AS AvgDurationMinutes

FROM msdb.dbo.sysjobs j
INNER JOIN msdb.dbo.sysjobschedules js ON j.job_id = js.job_id
INNER JOIN msdb.dbo.sysschedules s ON js.schedule_id = s.schedule_id
INNER JOIN msdb.dbo.sysschedules ss ON s.schedule_id = ss.schedule_id
LEFT JOIN msdb.dbo.sysjobhistory h ON j.job_id = h.job_id AND h.step_id = 0
LEFT JOIN JobDurations d ON j.job_id = d.job_id
ORDER BY NextRunDateTime;


1. DEV (Development Environment)

Purpose: Where developers write, unit test, and debug code.

Users: Developers.

Stability: Least stable, frequent changes, may have incomplete features.

Data: Dummy or very small sample data.

Goal: Quick iteration and code validation.

üîπ 2. SIT (System Integration Testing)

Purpose: Verify that different modules/services integrate correctly.

Users: Developers + integration testers.

Stability: More stable than DEV, but still may get frequent deployments.

Data: Larger test datasets, sometimes masked copies of production.

Goal: Test system-to-system flows (APIs, DB sync, messaging).

üîπ 3. QA (Quality Assurance Environment)

Purpose: Test overall functionality, regression, and bug fixes.

Users: QA testers (manual + automation).

Stability: More stable than SIT; resembles production setup.

Data: Test data (often masked prod data).

Goal: Validate that the application works as expected end-to-end.

üîπ 4. PERF (Performance / Load Testing Environment)

Purpose: Test how the system behaves under load, stress, and performance benchmarks.

Users: Performance engineers.

Stability: Built to mimic production scale (hardware/config).

Data: Large, production-like data sets.

Goal: Ensure system can handle expected (and peak) traffic.

üîπ 5. UAT (User Acceptance Testing)

Purpose: Let business users test and approve features against requirements.

Users: End-users, product owners, business stakeholders.

Stability: Very stable; minimal code changes.

Data: Often a copy of production data (sanitized/masked).

Goal: Confirm ‚Äúdoes the system meet business needs?‚Äù before go-live.

üîπ 6. PROD (Production Environment)

Purpose: The live environment where real users interact with the system.

Users: Customers, end-users.

Stability: Must be highly stable, monitored, secured.

Data: Real business data.

Goal: Deliver actual service to customers.
